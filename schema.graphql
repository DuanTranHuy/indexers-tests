enum Blockchain {
  ETHEREUM
  BSC
  XDAI
  POLYGON
  OPTIMISM
  AVALANCHE
  NEAR
}

enum AccountType {
  EOA
  CONTRACT
}

enum TokenStandard {
  ERC20
  ERC721
  ERC1155
}

enum ProtocolName {
  UNISWAP_V2
}

enum ProtocolType {
  STAKING
  LENDING
  EXCHANGE
  INSURANCE
  STABLECOIN
  DERIVATIVE
  SYNTHETIC_TOKEN
  TOKEN_MANAGEMENT  # Meta LP vaults
  PREDICTION_MARKET
}

enum PositionType {
  INVESTMENT
  DEBT
}

type Block @entity {
  id: ID! # {blockHash}
  number: BigInt!
  timestamp: BigInt!
}

type Account @entity {
  id: ID! # {accountAddress}
  type: AccountType!
  positions: [Position!]! @derivedFrom(field: "account")
}

type Token @entity {
  id: ID! # {tokenAddress}
  tokenStandard: TokenStandard!
  name: String
  symbol: String
  decimals: Int!
  createdAtBlock: Block # could be block at which we got first event on this token
}

type Market @entity {
  id: ID! # {protocol pair/pool/vault address}
  account: Account!
  protocolName: ProtocolName!
  protocolType: ProtocolType!
  inputTokens: [Token!]!   # Tokens that need to be deposited to take a position in protocol
  outputToken: Token       # Token that is minted to track ownership of position in protocol
  rewardTokens: [Token!]   # Aditional tokens that are given as reward for position in a protocol
  canBeReinvestedInTo: [Account!]!
  createdAtBlock: Block!
}

type Transaction @entity {
  id: ID! # {transactionHash}
  market: Market!
  from: Account!
  to: Account
  gasUsed: BigInt!
  gasPrice: BigInt!
  createdAtBlock: Block!
  transactionIndexInBlock: BigInt!
}

# String format for a TokenBalance
# tokenAddress|accountAddress|tokenAmountBigInt|tokenAmountInWei

# It is required because we want to keep track of closed positions as well
# We can not use same ID for a user's new position after existing one has been closed
# To be able to fetch current open position for a user + market + position type we need
# ID to be dependent on only these three things. These three things will be same for all positions
# of a specific user in specfic market therefore we need this AccountPosition entity
type AccountPosition @entity {
  id: ID! # {userAddress}{marketAddress}{positionType}
  positions: [Position!]! @derivedFrom(field: "accountPosition")
}

type Position @entity {
  id: ID! # {accountPositionId}{autoIncrement}
  accountPosition: AccountPosition!
  account: Account!
  market: Market!
  positionType: PositionType!
  investmentAmounts: [String!]!     # TokenBalance string format
  outputTokenBalance: BigInt!
  outputTokenBalanceInETH: BigInt!  # in Wei
  inputTokenBalances: [String!]!    # TokenBalance string format
  rewardTokenBalances: [String!]!   # TokenBalance string format
  reinvestments: [String!]!         # TokenBalance string format
  roiInEth: BigInt!
  roiPercentageInEth: BigDecimal!
  closed: Boolean!
  createdAtBlock: Block!
  updatedAtBlock: Block!
  history: [PositionSnapshot!]! @derivedFrom(field: "position")
}

type PositionSnapshot @entity {
  id: ID! # {positionId}{autoIncrement}
  position: Position!
  transaction: Transaction!
  investmentAmounts: [String!]!     # TokenBalance string format
  outputTokenBalance: BigInt!
  outputTokenBalanceInETH: BigInt!
  inputTokenBalances: [String!]!    # TokenBalance string format
  rewardTokenBalances: [String!]!   # TokenBalance string format
  reinvestments: [String!]!         # TokenBalance string format
  roiInEth: BigInt!
  roiPercentageInEth: BigDecimal!
}

type Pair @entity {
  id: ID! # {pairAddress}
  factory: Account!
  token0: Token!
  token1: Token!
  feeTo: Account!
  createdAtBlock: Block!
  history: [PairSnapshot!]! @derivedFrom(field: "pair")
}

type PairSnapshot @entity {
  id: ID! # {trasactionHash}{logIndex}
  pair: Pair!
  reserve0: BigInt!
  reserve1: BigInt!
  feeTo: Account!
  createdAtBlock: Block!
  transactionHash: String!
  transactionIndexInBlock: BigInt!
  logIndex: BigInt!
}

type Mint @entity {
  id: ID! # {trasactionHash}
  pair: Pair
  to: Account
  liquityAmount: BigInt
  amount0: BigInt
  amount1: BigInt
}

type Burn @entity {
  id: ID! # {trasactionHash}
  pair: Pair
  to: Account
  liquityAmount: BigInt
  amount0: BigInt
  amount1: BigInt
}
